Prefix(:=<http://www.omg.org/spec/API4KP/core#>)
Prefix(dc:=<http://purl.org/dc/elements/1.1/>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(dc-t:=<http://purl.org/dc/terms/>)
Prefix(foaf:=<http://xmlns.com/foaf/0.1/>)
Prefix(know:=<http://www.omg.org/spec/API4KP/core#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(skos:=<http://www.w3.org/2004/02/skos/core#>)
Prefix(vann:=<http://purl.org/vocab/vann/>)
Prefix(SpecificationMetadata:=<http://www.omg.org/techprocess/ab/SpecificationMetadata/>)


Ontology(<http://www.omg.org/spec/API4KP/core>
<http://www.omg.org/spec/API4KP/2017/12/core>
Annotation(dc:description "This ontology defines the core concepts of the API4KP framework: Knowledge, Resources, Operations and Platforms, serving as an 'upper ontology' for the specification")
Annotation(dc:title "API4KP Core Ontology")

Declaration(Class(know:AbstractExpression))
Declaration(Class(know:AbstractSyntax))
Declaration(Class(know:AbstractSyntaxTree))
Declaration(Class(know:Activity))
Declaration(Class(know:Agent))
Declaration(Class(know:AgentiveRole))
Declaration(Class(know:ArtificialAgent))
Declaration(Class(know:AtomicConcept))
Declaration(Class(know:ComplexConcept))
Declaration(Class(know:CompositeKnowledgeResource))
Declaration(Class(know:ComputableLanguage))
Declaration(Class(know:ConcreteExpression))
Declaration(Class(know:ConstructedLanguage))
Declaration(Class(know:ConstructiveDefinition))
Declaration(Class(know:ControlledNaturalLanguage))
Declaration(Class(know:DefinedConcept))
Declaration(Class(know:Definition))
Declaration(Class(know:DescriptiveGrammar))
Declaration(Class(know:EncodedKnowledgeExpression))
Declaration(Class(know:Encoding))
Declaration(Class(know:FormalGrammar))
Declaration(Class(know:FormalLanguage))
Declaration(Class(know:Grammar))
Declaration(Class(know:Identifier))
Declaration(Class(know:InformationProcessingActivity))
Declaration(Class(know:IntellectualWork))
Declaration(Class(know:Knowledge))
Declaration(Class(know:KnowledgeActivity))
Declaration(Class(know:KnowledgeArtifact))
Declaration(Class(know:KnowledgeArtifactRepository))
Declaration(Class(know:KnowledgeAssetSurrogate))
Declaration(Class(know:KnowledgeCarrier))
Declaration(Class(know:KnowledgeConstructionActivity))
Declaration(Class(know:KnowledgeElement))
Declaration(Class(know:KnowledgeEndeavour))
Declaration(Class(know:KnowledgeExpression))
Declaration(Class(know:KnowledgeFragment))
Declaration(Class(know:KnowledgeManifestation))
Declaration(Class(know:KnowledgeProcessingFunction))
Declaration(Class(know:KnowledgeProcessingMethod))
Declaration(Class(know:KnowledgeProcessingPlan))
Declaration(Class(know:KnowledgeProcessingTask))
Declaration(Class(know:KnowledgeRepresentationAndReasoningLanguage))
Declaration(Class(know:KnowledgeResource))
Declaration(Class(know:KnowledgeResourceDescription))
Declaration(Class(know:KnowledgeStructuringActivity))
Declaration(Class(know:KnowledgeableAgent))
Declaration(Class(know:Language))
Declaration(Class(know:Lexicon))
Declaration(Class(know:MachineExecutableLanguage))
Declaration(Class(know:MachineReadableLanguage))
Declaration(Class(know:Model))
Declaration(Class(know:NaturalLanguage))
Declaration(Class(know:Ontology))
Declaration(Class(know:ParseTree))
Declaration(Class(know:PassiveRole))
Declaration(Class(know:PieceOfKnowledge))
Declaration(Class(know:PrescriptiveGrammar))
Declaration(Class(know:PrimitiveConcept))
Declaration(Class(know:Profile))
Declaration(Class(know:SelfContainedKnowledgeArtifact))
Declaration(Class(know:Serialization))
Declaration(Class(know:Software))
Declaration(Class(know:Specification))
Declaration(Class(know:StructuredKnowledgeResource))
Declaration(Class(know:StructuringKnowledgeResource))
Declaration(Class(know:Syntax))
Declaration(Class(know:VersionedIdentifier))
Declaration(Class(know:VersionedKnowledgeEndeavor))
Declaration(Class(know:WorkOfKnowledge))
Declaration(ObjectProperty(know:archetyped-by))
Declaration(ObjectProperty(know:archetypes))
Declaration(ObjectProperty(know:associated-to))
Declaration(ObjectProperty(know:captured-by))
Declaration(ObjectProperty(know:captures))
Declaration(ObjectProperty(know:carried-by))
Declaration(ObjectProperty(know:carries))
Declaration(ObjectProperty(know:completely-expresses))
Declaration(ObjectProperty(know:conceptualizes))
Declaration(ObjectProperty(know:concisely-expresses))
Declaration(ObjectProperty(know:concretely-expressed-by))
Declaration(ObjectProperty(know:concretely-expresses))
Declaration(ObjectProperty(know:conforms-with))
Declaration(ObjectProperty(know:consistently-expresses))
Declaration(ObjectProperty(know:defined-by))
Declaration(ObjectProperty(know:defines))
Declaration(ObjectProperty(know:denoted-by))
Declaration(ObjectProperty(know:denotes))
Declaration(ObjectProperty(know:described-by))
Declaration(ObjectProperty(know:encoding-of))
Declaration(ObjectProperty(know:engraved-on))
Declaration(ObjectProperty(know:engraved-with))
Declaration(ObjectProperty(know:exemplar-of))
Declaration(ObjectProperty(know:expresses))
Declaration(ObjectProperty(know:externalizes))
Declaration(ObjectProperty(know:faithfully-expresses))
Declaration(ObjectProperty(know:formalizes))
Declaration(ObjectProperty(know:function-of))
Declaration(ObjectProperty(know:governed-by))
Declaration(ObjectProperty(know:has-encoding))
Declaration(ObjectProperty(know:has-exemplar))
Declaration(ObjectProperty(know:has-function))
Declaration(ObjectProperty(know:has-knowledge))
Declaration(ObjectProperty(know:has-part))
Declaration(ObjectProperty(know:has-product))
Declaration(ObjectProperty(know:has-proper-part))
Declaration(ObjectProperty(know:has-subject))
Declaration(ObjectProperty(know:has-wordstock))
Declaration(ObjectProperty(know:identified-by))
Declaration(ObjectProperty(know:identifies))
Declaration(ObjectProperty(know:internally-represented-by))
Declaration(ObjectProperty(know:internally-represents))
Declaration(ObjectProperty(know:involved-in))
Declaration(ObjectProperty(know:involves))
Declaration(ObjectProperty(know:is-about))
Declaration(ObjectProperty(know:is-serialized-in))
Declaration(ObjectProperty(know:knowledge-representation-of))
Declaration(ObjectProperty(know:limits))
Declaration(ObjectProperty(know:makes-use-of))
Declaration(ObjectProperty(know:part-of))
Declaration(ObjectProperty(know:performed-by))
Declaration(ObjectProperty(know:performs))
Declaration(ObjectProperty(know:preserves))
Declaration(ObjectProperty(know:product-of))
Declaration(ObjectProperty(know:profiles))
Declaration(ObjectProperty(know:proper-part-of))
Declaration(ObjectProperty(know:recipient-of))
Declaration(ObjectProperty(know:refines))
Declaration(ObjectProperty(know:representation-of))
Declaration(ObjectProperty(know:represented-by))
Declaration(ObjectProperty(know:reproduced-by))
Declaration(ObjectProperty(know:reproduces))
Declaration(ObjectProperty(know:serialization-of))
Declaration(ObjectProperty(know:serialized-into))
Declaration(ObjectProperty(know:serializes))
Declaration(ObjectProperty(know:specified-by))
Declaration(ObjectProperty(know:stored-in))
Declaration(ObjectProperty(know:stores))
Declaration(ObjectProperty(know:supports-expression))
Declaration(ObjectProperty(know:supports-serialization))
Declaration(ObjectProperty(know:targets))
Declaration(ObjectProperty(know:unambiguously-expresses))
Declaration(ObjectProperty(know:used-in))
Declaration(ObjectProperty(know:uses-annotation-language))
Declaration(ObjectProperty(know:uses-as-sublanguage))
Declaration(ObjectProperty(know:uses-concept))
Declaration(ObjectProperty(know:uses-concrete-syntax))
Declaration(ObjectProperty(know:uses-language))
Declaration(ObjectProperty(know:uses-lexicon))
Declaration(ObjectProperty(know:uses-primary-language))
Declaration(ObjectProperty(know:uses-profile))
Declaration(ObjectProperty(know:uses-syntax))
Declaration(AnnotationProperty(dc:creator))
Declaration(AnnotationProperty(dc:date))
Declaration(AnnotationProperty(dc:description))
Declaration(AnnotationProperty(dc:title))
Declaration(AnnotationProperty(skos:altLabel))
Declaration(AnnotationProperty(skos:definition))
Declaration(AnnotationProperty(skos:example))
Declaration(AnnotationProperty(skos:note))
Declaration(AnnotationProperty(skos:scopeNote))

############################
#   Object Properties
############################

# Object Property: know:archetyped-by (archetyped by)

AnnotationAssertion(rdfs:label know:archetyped-by "archetyped by")
AnnotationAssertion(skos:altLabel know:archetyped-by "classified by")
AnnotationAssertion(skos:altLabel know:archetyped-by "instance of")
SubObjectPropertyOf(know:archetyped-by know:has-knowledge)
InverseObjectProperties(know:archetyped-by know:archetypes)
ObjectPropertyRange(know:archetyped-by know:AtomicConcept)

# Object Property: know:archetypes (archetypes)

AnnotationAssertion(rdfs:comment know:archetypes "a concept archetypes a referent, to the extent that the concept is defined by a definition that has that referent as a subject.")
AnnotationAssertion(rdfs:label know:archetypes "archetypes")
AnnotationAssertion(rdfs:seeAlso know:archetypes "inverse http://www.w3.org/ns/lemon/ontolex#concept")
SubObjectPropertyOf(know:archetypes know:is-about)
ObjectPropertyDomain(know:archetypes know:DefinedConcept)

# Object Property: know:associated-to (associated to)

AnnotationAssertion(rdfs:comment know:associated-to "this is an 'explicit' and 'conscious' notion of association which, in order to be asserted, requires that at least one agent has explicitly identified and called out the close relationship between the two concepts")
AnnotationAssertion(rdfs:label know:associated-to "associated to")
AnnotationAssertion(skos:definition know:associated-to "two concepts are associated to each other if there exists at least one work of knowledge that makes their relationship explicit")
ObjectPropertyDomain(know:associated-to know:AtomicConcept)
ObjectPropertyRange(know:associated-to know:AtomicConcept)

# Object Property: know:captured-by (captured by)

AnnotationAssertion(rdfs:label know:captured-by "captured by")
AnnotationAssertion(rdfs:label know:captured-by "the relationship between a (piece of) Knowledge and any Work of Knowledge that makes it finite, explicit and potentially communicable")
SubObjectPropertyOf(know:captured-by know:has-knowledge)
InverseObjectProperties(know:captured-by know:captures)
ObjectPropertyDomain(know:captured-by know:Knowledge)
ObjectPropertyRange(know:captured-by know:WorkOfKnowledge)

# Object Property: know:captures (captures)

AnnotationAssertion(rdfs:label know:captures "captures")
AnnotationAssertion(skos:definition know:captures "a specific relationship between a work of knowledge and the (piece of) knowledge it makes explicit")
SubObjectPropertyOf(know:captures know:is-about)
ObjectPropertyDomain(know:captures know:WorkOfKnowledge)
ObjectPropertyRange(know:captures know:Knowledge)

# Object Property: know:carried-by (carried by)

AnnotationAssertion(rdfs:label know:carried-by "The relationship between an (concrete serialization) of an expression and an exemplar of a manifestation that embodies it")
AnnotationAssertion(rdfs:label know:carried-by "carried by"@en)
InverseObjectProperties(know:carried-by know:carries)
ObjectPropertyDomain(know:carried-by know:KnowledgeExpression)
ObjectPropertyRange(know:carried-by know:KnowledgeCarrier)

# Object Property: know:carries (carries)

AnnotationAssertion(rdfs:label know:carries "carries")
AnnotationAssertion(skos:definition know:carries "The direct relationship between a Concrete Information Carrier and an Expression, such that the object is an exemplar of a manifestation that embodies a (concrete representation of) that Expression")
ObjectPropertyDomain(know:carries know:KnowledgeCarrier)
ObjectPropertyRange(know:carries know:KnowledgeExpression)

# Object Property: know:completely-expresses (completely expresses)

AnnotationAssertion(rdfs:comment know:completely-expresses "no concept in the WoK is left implicit")
AnnotationAssertion(rdfs:label know:completely-expresses "completely expresses")
AnnotationAssertion(skos:definition know:completely-expresses "every concept in the WoK must be expressed by at least one element of the expression")
SubObjectPropertyOf(know:completely-expresses know:expresses)

# Object Property: know:conceptualizes (conceptualizes)

AnnotationAssertion(rdfs:comment know:conceptualizes "Reflects the relationship between the expression's Abstract Syntax Tree and the Abstract Semantic Graph of (a WoK that is the faithful expression of) the Knowledge content of the expression.")
AnnotationAssertion(rdfs:label know:conceptualizes "conceptualizes")
AnnotationAssertion(skos:altLabel know:conceptualizes "has expression")
AnnotationAssertion(skos:definition know:conceptualizes "The relationship between a (Work of) Knowledge and any of its Expressions, for which the Work represents a class of equivalence")
SubObjectPropertyOf(know:conceptualizes know:represented-by)
InverseObjectProperties(know:conceptualizes know:expresses)
ObjectPropertyDomain(know:conceptualizes know:WorkOfKnowledge)
ObjectPropertyRange(know:conceptualizes know:AbstractExpression)

# Object Property: know:concisely-expresses (concisely expresses)

AnnotationAssertion(rdfs:comment know:concisely-expresses "no element in the epxression is redundant")
AnnotationAssertion(rdfs:label know:concisely-expresses "concisely expresses")
AnnotationAssertion(skos:definition know:concisely-expresses "when conceptualized, every element of the expression corresponds to some concept that is part of the original WoK")
SubObjectPropertyOf(know:concisely-expresses know:expresses)

# Object Property: know:concretely-expressed-by (concretely expressed by)

AnnotationAssertion(rdfs:label know:concretely-expressed-by "concretely expressed by")
AnnotationAssertion(skos:definition know:concretely-expressed-by "A Work of Knowledge W is concretely expressed by a Concrete Expression E, if and only if there is an Abstract Expression of that Work W of which E is a concrete representation")
InverseObjectProperties(know:concretely-expressed-by know:concretely-expresses)
ObjectPropertyDomain(know:concretely-expressed-by know:WorkOfKnowledge)
ObjectPropertyRange(know:concretely-expressed-by know:ConcreteExpression)

# Object Property: know:concretely-expresses (concretely expresses)

AnnotationAssertion(rdfs:label know:concretely-expresses "concretely expresses")
ObjectPropertyDomain(know:concretely-expresses know:ConcreteExpression)
ObjectPropertyRange(know:concretely-expresses know:WorkOfKnowledge)

# Object Property: know:conforms-with (conforms with)

AnnotationAssertion(rdfs:label know:conforms-with "conforms with")
AnnotationAssertion(skos:altLabel know:conforms-with "valid according to")
AnnotationAssertion(skos:definition know:conforms-with "An expression conforms to, and is valid according to, the rules of the grammar of a language, as expressed by some syntax (abstract or concrete)")
ObjectPropertyDomain(know:conforms-with know:KnowledgeExpression)
ObjectPropertyRange(know:conforms-with know:Syntax)

# Object Property: know:consistently-expresses (consistently expresses)

AnnotationAssertion(rdfs:label know:consistently-expresses "consistently expresses")
AnnotationAssertion(skos:definition know:consistently-expresses "every concept in the WoK is always represented by the same element every time it is mentioned in the expression")
SubObjectPropertyOf(know:consistently-expresses know:expresses)

# Object Property: know:defined-by (defined by)

AnnotationAssertion(rdfs:label know:defined-by "A Work of Knowledge defines a concept if it provides necessary and sufficient knowledge to allow to recognize instances of that concept")
AnnotationAssertion(rdfs:label know:defined-by "defined by")
SubObjectPropertyOf(know:defined-by know:captured-by)
ObjectPropertyDomain(know:defined-by know:DefinedConcept)
ObjectPropertyRange(know:defined-by know:WorkOfKnowledge)

# Object Property: know:defines (know:defines)

SubObjectPropertyOf(know:defines know:captures)
ObjectPropertyDomain(know:defines know:Definition)
ObjectPropertyRange(know:defines know:DefinedConcept)

# Object Property: know:denoted-by (denoted by)

AnnotationAssertion(rdfs:label know:denoted-by "denoted by")
AnnotationAssertion(skos:definition know:denoted-by "the relationship between a referent and a symbolic expression that resolves to that referent, possibly within a given context")
InverseObjectProperties(know:denoted-by know:denotes)
ObjectPropertyRange(know:denoted-by know:KnowledgeElement)

# Object Property: know:denotes (denotes)

AnnotationAssertion(rdfs:label know:denotes "denotes")
AnnotationAssertion(rdfs:seeAlso know:denotes "http://www.w3.org/ns/lemon/ontolex#denotes")
AnnotationAssertion(skos:definition know:denotes "the semiotic relationship between a linguistic expression and its referent, where the former references the latter, possibly within a context")
ObjectPropertyDomain(know:denotes know:KnowledgeElement)

# Object Property: know:described-by (described by)

AnnotationAssertion(rdfs:label know:described-by "described by")
AnnotationAssertion(skos:definition know:described-by "The relationship between Something and its description - a (descriptive) expression of a work of knowledge that represents what that thing is (ontology) and/or how it behaves (model)")
SubObjectPropertyOf(know:described-by know:represented-by)
ObjectPropertyRange(know:described-by know:AbstractExpression)

# Object Property: know:encoding-of (encoding of)

AnnotationAssertion(rdfs:label know:encoding-of "encoding of")
InverseObjectProperties(know:encoding-of know:has-encoding)
ObjectPropertyDomain(know:encoding-of know:EncodedKnowledgeExpression)
ObjectPropertyRange(know:encoding-of know:ConcreteExpression)

# Object Property: know:engraved-on (engraved on)

AnnotationAssertion(rdfs:label know:engraved-on "engraved on")
AnnotationAssertion(skos:definition know:engraved-on "the relationship between an encoding and its carrier")
InverseObjectProperties(know:engraved-on know:engraved-with)
ObjectPropertyDomain(know:engraved-on know:EncodedKnowledgeExpression)
ObjectPropertyRange(know:engraved-on know:KnowledgeCarrier)

# Object Property: know:engraved-with (engraved with)

AnnotationAssertion(rdfs:label know:engraved-with "engraved with")
ObjectPropertyDomain(know:engraved-with know:KnowledgeCarrier)
ObjectPropertyRange(know:engraved-with know:EncodedKnowledgeExpression)

# Object Property: know:exemplar-of (exemplar of)

AnnotationAssertion(rdfs:label know:exemplar-of "exemplar of")
AnnotationAssertion(skos:definition know:exemplar-of "an individual artifact is an exemplar of a knowledge manifestation, which conceptualizes (and defines) the qualities of that artifact and all its copies")
SubObjectPropertyOf(know:exemplar-of know:archetyped-by)
InverseObjectProperties(know:exemplar-of know:has-exemplar)
ObjectPropertyDomain(know:exemplar-of know:KnowledgeArtifact)
ObjectPropertyRange(know:exemplar-of know:KnowledgeManifestation)

# Object Property: know:expresses (expresses)

AnnotationAssertion(rdfs:label know:expresses "expresses")
AnnotationAssertion(skos:definition know:expresses "The relationship between a (Knowledge) Expression in some language and its knowledge content.
Reflects the relationship between the expression's Abstract Syntax Tree and an Abstract Semantic Graph that captures the Knowledge content of the expression. That is, if an expression E expresses some Knowledge K, there is at least one WoK that captures K and that is faithfully expressed by E")
AnnotationAssertion(skos:note know:expresses "Reasoners do not support the property chain 
expresses (WoK) o captures -> expresses")
ObjectPropertyDomain(know:expresses know:AbstractExpression)
ObjectPropertyRange(know:expresses know:WorkOfKnowledge)

# Object Property: know:externalizes (externalizes)

AnnotationAssertion(rdfs:label know:externalizes "externalizes")
AnnotationAssertion(skos:definition know:externalizes "The relationship between a Concrete Syntax and its Abstract Syntax. The Concrete syntax adds the constructs (e.g. constraints, rules) that make sentences parseable")
SubObjectPropertyOf(know:externalizes know:refines)
ObjectPropertyDomain(know:externalizes know:Serialization)
ObjectPropertyRange(know:externalizes know:AbstractSyntax)

# Object Property: know:faithfully-expresses (faithfully expresses)

AnnotationAssertion(rdfs:label know:faithfully-expresses "faithfully expresses")
AnnotationAssertion(skos:definition know:faithfully-expresses "a faithful expression is both complete and correct, i.e. it is complete and  preserves all and only the associations between the concepts in the WoK")
SubObjectPropertyOf(know:faithfully-expresses know:completely-expresses)

# Object Property: know:formalizes (know:formalizes)

AnnotationAssertion(skos:definition know:formalizes "An Expression formalizes a Work of Knowledge if (i) it uses a formal language and (ii) it faithfully, concisely, consistently and unambiguously expresses that WoK")
SubObjectPropertyOf(know:formalizes know:concisely-expresses)
SubObjectPropertyOf(know:formalizes know:consistently-expresses)
SubObjectPropertyOf(know:formalizes know:faithfully-expresses)
SubObjectPropertyOf(know:formalizes know:unambiguously-expresses)
ObjectPropertyDomain(know:formalizes know:KnowledgeExpression)
ObjectPropertyRange(know:formalizes know:WorkOfKnowledge)

# Object Property: know:function-of (function of)

AnnotationAssertion(rdfs:label know:function-of "function of")
AnnotationAssertion(skos:definition know:function-of "the relationship between an entity and the concept that abstracts its function")
SubObjectPropertyOf(know:function-of know:archetypes)
InverseObjectProperties(know:function-of know:has-function)
ObjectPropertyDomain(know:function-of know:KnowledgeProcessingFunction)

# Object Property: know:governed-by (governed by)

AnnotationAssertion(rdfs:label know:governed-by "governed by")
AnnotationAssertion(skos:definition know:governed-by "the relationship between a grammar, intended as the conceptualization of the rules, structures and constraints that define a language intensionally, and that language")
ObjectPropertyDomain(know:governed-by know:Language)
ObjectPropertyRange(know:governed-by know:Grammar)

# Object Property: know:has-encoding (has encoding)

AnnotationAssertion(rdfs:label know:has-encoding "has encoding")
AnnotationAssertion(skos:definition know:has-encoding "the relationship between a concrete expresison and its encoded version")
ObjectPropertyDomain(know:has-encoding know:ConcreteExpression)
ObjectPropertyRange(know:has-encoding know:EncodedKnowledgeExpression)

# Object Property: know:has-exemplar (has exemplar)

AnnotationAssertion(rdfs:label know:has-exemplar "has exemplar")
SubObjectPropertyOf(know:has-exemplar know:archetypes)
ObjectPropertyDomain(know:has-exemplar know:KnowledgeManifestation)
ObjectPropertyRange(know:has-exemplar know:KnowledgeArtifact)

# Object Property: know:has-function (has function)

AnnotationAssertion(rdfs:label know:has-function "has function")
SubObjectPropertyOf(know:has-function know:archetyped-by)
ObjectPropertyRange(know:has-function know:KnowledgeProcessingFunction)

# Object Property: know:has-knowledge (has knowledge)

AnnotationAssertion(rdfs:label know:has-knowledge "has knowledge")
AnnotationAssertion(skos:definition know:has-knowledge "the abstract relationship between an entity, and what is known about that entity")
InverseObjectProperties(know:has-knowledge know:is-about)
ObjectPropertyRange(know:has-knowledge know:Knowledge)

# Object Property: know:has-part (has part)

AnnotationAssertion(rdfs:label know:has-part "has part")
InverseObjectProperties(know:has-part know:part-of)

# Object Property: know:has-product (has product)

AnnotationAssertion(rdfs:label know:has-product "has product")
AnnotationAssertion(skos:definition know:has-product "The relationship between an Activity and an entity that is created as part of the Activity, i.e. an entity that did not exist before the Activity was started, exists after the completion of the activity, and exists because the Activity took place")
SubObjectPropertyOf(know:has-product know:involves)
InverseObjectProperties(know:has-product know:product-of)
ObjectPropertyDomain(know:has-product know:Activity)

# Object Property: know:has-proper-part (has proper part)

AnnotationAssertion(rdfs:label know:has-proper-part "has proper part")
SubObjectPropertyOf(know:has-proper-part know:has-part)
InverseObjectProperties(know:has-proper-part know:proper-part-of)

# Object Property: know:has-subject (has subject (knowledge))

AnnotationAssertion(rdfs:label know:has-subject "conceptual representation of")
AnnotationAssertion(rdfs:label know:has-subject "has subject (knowledge)")
AnnotationAssertion(skos:definition know:has-subject "a WoK is a (knowledge) representation of something if knowledge about that something is the subject of that WoK and thus that subject is indirectly the subject of that WoK")
SubObjectPropertyOf(know:has-subject know:is-about)
ObjectPropertyDomain(know:has-subject know:WorkOfKnowledge)

# Object Property: know:has-wordstock (has wordstock)

AnnotationAssertion(rdfs:label know:has-wordstock "has wordstock")
AnnotationAssertion(skos:definition know:has-wordstock "The relationship between a Language, and the set of linguistic elements that can be formed into valid sentences of the language according to the language's syntax")
ObjectPropertyDomain(know:has-wordstock know:Language)
ObjectPropertyRange(know:has-wordstock know:Lexicon)

# Object Property: know:identified-by (identified by)

AnnotationAssertion(rdfs:label know:identified-by "identified by")
SubObjectPropertyOf(know:identified-by know:denoted-by)
InverseObjectProperties(know:identified-by know:identifies)
ObjectPropertyRange(know:identified-by know:Identifier)

# Object Property: know:identifies (identifies)

AnnotationAssertion(rdfs:label know:identifies "identifies")
AnnotationAssertion(skos:definition know:identifies "an identifier uniquely and unambiguously denotes its referent")
SubObjectPropertyOf(know:identifies know:denotes)
ObjectPropertyDomain(know:identifies know:Identifier)

# Object Property: know:internally-represented-by (internally represented by)

AnnotationAssertion(rdfs:label know:internally-represented-by "internally represented by")
InverseObjectProperties(know:internally-represented-by know:internally-represents)
ObjectPropertyDomain(know:internally-represented-by know:KnowledgeEndeavour)
ObjectPropertyRange(know:internally-represented-by know:KnowledgeableAgent)

# Object Property: know:internally-represents (has internal representation of)

AnnotationAssertion(rdfs:label know:internally-represents "has internal representation of")
AnnotationAssertion(rdfs:label know:internally-represents "internally represents"@en)
AnnotationAssertion(skos:definition know:internally-represents "An Agent an internal representation of a Knowledge Endeavor if and only if there exists an internal 'carrier' (neurons, but also a digital memory) that carries an encoded representation of all the Concepts, and their associations, scoped by the Endeavor")
ObjectPropertyDomain(know:internally-represents know:KnowledgeableAgent)
ObjectPropertyRange(know:internally-represents know:KnowledgeEndeavour)

# Object Property: know:involved-in (involved in)

AnnotationAssertion(rdfs:label know:involved-in "involved in")
AnnotationAssertion(skos:altLabel know:involved-in "participates in")
AnnotationAssertion(skos:definition know:involved-in "the relationship between a participant in some activity and that activity")
InverseObjectProperties(know:involved-in know:involves)
ObjectPropertyRange(know:involved-in know:Activity)

# Object Property: know:involves (involves)

AnnotationAssertion(rdfs:label know:involves "involves")
AnnotationAssertion(skos:altLabel know:involves "has participant")
AnnotationAssertion(skos:definition know:involves "The relationship between an Activity and a participant - Agent (acitive) or Resource (passive)
Conceptually, this relationship is mediated by an 'entity qua' individual that represents the participant's temporary play of a given role in the context of the activity.")
AnnotationAssertion(skos:scopeNote know:involves "in this ontology, \"roles\" are explicitly modeled as concepts, but their realization in space and time by an entity is left implicit.")
ObjectPropertyDomain(know:involves know:Activity)

# Object Property: know:is-about (knowledge of)

AnnotationAssertion(rdfs:comment know:is-about "A kind of 'aboutness' that reflects the relationship between a a knowledge-related conceptualization and its referent(s)")
AnnotationAssertion(rdfs:label know:is-about "knowledge of")
AnnotationAssertion(skos:definition know:is-about "The relationship between a (piece of) Knowledge and its referent")
ObjectPropertyDomain(know:is-about know:Knowledge)

# Object Property: know:is-serialized-in (has serialized representation in)

AnnotationAssertion(rdfs:label know:is-serialized-in "has serialized representation in"@en)
AnnotationAssertion(skos:definition know:is-serialized-in "An abstract expression X has a serialized representation in a concrete syntax Y if there exists at least one concrete representation of X in Y")
ObjectPropertyDomain(know:is-serialized-in know:AbstractExpression)
ObjectPropertyRange(know:is-serialized-in know:Serialization)

# Object Property: know:knowledge-representation-of (knowledge representation of)

AnnotationAssertion(rdfs:label know:knowledge-representation-of "knowledge representation of")
AnnotationAssertion(skos:definition know:knowledge-representation-of "relates a Knowledge Expression to the Knowledge that is captured by the (implicit) Work of Knowledge that the Expression expresses")
SubObjectPropertyOf(know:knowledge-representation-of know:representation-of)
ObjectPropertyDomain(know:knowledge-representation-of know:KnowledgeExpression)
ObjectPropertyRange(know:knowledge-representation-of know:Knowledge)

# Object Property: know:limits (know:limits)

AnnotationAssertion(skos:definition know:limits "The relationship between a Concrete Syntax S1 and a Concrete Syntax S2, where S2 is strictly more constrained than S1 in terms of admissible constructs.")
SubObjectPropertyOf(know:limits know:refines)
ObjectPropertyDomain(know:limits know:Serialization)
ObjectPropertyRange(know:limits know:Serialization)

# Object Property: know:makes-use-of (makes use of)

AnnotationAssertion(rdfs:comment know:makes-use-of "The relationship between an Activity and a non-agentive resource that is used by an Agent performing that Activity")
AnnotationAssertion(rdfs:label know:makes-use-of "makes use of")
SubObjectPropertyOf(know:makes-use-of know:involves)
InverseObjectProperties(know:makes-use-of know:used-in)
ObjectPropertyDomain(know:makes-use-of know:Activity)

# Object Property: know:part-of (part of)

AnnotationAssertion(rdfs:label know:part-of "part of")
AnnotationAssertion(skos:definition know:part-of "Generic, homeomeric parthood relationship")

# Object Property: know:performed-by (performed by)

AnnotationAssertion(rdfs:label know:performed-by "performed by")
AnnotationAssertion(skos:definition know:performed-by "The relationship between an Activity and an Agent whose work contributes to the completion of the Activity")
SubObjectPropertyOf(know:performed-by know:involves)
InverseObjectProperties(know:performed-by know:performs)
ObjectPropertyDomain(know:performed-by know:Activity)
ObjectPropertyRange(know:performed-by know:Agent)

# Object Property: know:performs (know:performs)

SubObjectPropertyOf(know:performs know:involved-in)
ObjectPropertyDomain(know:performs know:Agent)
ObjectPropertyRange(know:performs know:Activity)

# Object Property: know:preserves (preserves)

AnnotationAssertion(rdfs:label know:preserves "preserves")
AnnotationAssertion(skos:definition know:preserves "A method M (subject) preserves an entity E of type T (object) if: 
- for any entity X 
  - if X is related to E by R
  and X is input of an activity A 
  and A is based on M
  and A produces an output O
then:
  O is also related to E by R")
AnnotationAssertion(skos:example know:preserves "A transcription method, by definition, defines how to create different concrete expressions, but preserves the language (abstract syntax)")
ObjectPropertyDomain(know:preserves know:KnowledgeProcessingMethod)

# Object Property: know:product-of (product of)

AnnotationAssertion(rdfs:label know:product-of "product of")
SubObjectPropertyOf(know:product-of know:involved-in)
ObjectPropertyRange(know:product-of know:Activity)

# Object Property: know:profiles (profiles)

AnnotationAssertion(rdfs:label know:profiles "profiles")
AnnotationAssertion(skos:definition know:profiles "The relationship between a Profile of an Abstract Syntax and that Abstract Syntax. A profile is more restrictive in some sense, i.e. has no less constraints")
SubObjectPropertyOf(know:profiles know:refines)
ObjectPropertyDomain(know:profiles know:Profile)
ObjectPropertyRange(know:profiles know:AbstractSyntax)

# Object Property: know:proper-part-of (proper part of)

AnnotationAssertion(rdfs:label know:proper-part-of "proper part of")
AnnotationAssertion(skos:definition know:proper-part-of "Parthood relationship that is irreflexive, i.e. such that no individual is allowed to be proper part of itself")
SubObjectPropertyOf(know:proper-part-of know:part-of)
IrreflexiveObjectProperty(know:proper-part-of)

# Object Property: know:recipient-of (recipient of)

AnnotationAssertion(rdfs:label know:recipient-of "recipient of")
AnnotationAssertion(skos:definition know:recipient-of "an entity is the recipient of an activity if that activity targets that entity")
SubObjectPropertyOf(know:recipient-of know:involved-in)
InverseObjectProperties(know:recipient-of know:targets)
ObjectPropertyRange(know:recipient-of know:Activity)

# Object Property: know:refines (know:refines)

AnnotationAssertion(rdfs:comment know:refines "The relationship between two Syntaxes S1 and S2, such that the set of rules and constraints of S1 is no less permissive than S2, i.e. a sentence that is valid according to S2 must be valid according to S1.")
AnnotationAssertion(rdfs:comment know:refines "This relationships is used in several ways:
(i) to state that a concrete syntax externalizes an abstract one, allowing to create parse trees and defining how a parse tree reduces to an AST
(ii) to define sub-languages that conform to certain profiles, based on semantic constraints on the abstract syntax
(iii) to define specialized versions of a concrete syntax")
TransitiveObjectProperty(know:refines)
ObjectPropertyDomain(know:refines know:Syntax)
ObjectPropertyRange(know:refines know:Syntax)

# Object Property: know:representation-of (representation of)

AnnotationAssertion(rdfs:label know:representation-of "representation of")
AnnotationAssertion(skos:definition know:representation-of "an expression of a conceptual representation of something")
InverseObjectProperties(know:representation-of know:represented-by)
ObjectPropertyDomain(know:representation-of know:KnowledgeExpression)

# Object Property: know:represented-by (represented by)

AnnotationAssertion(rdfs:label know:represented-by "represented by")
AnnotationAssertion(skos:definition know:represented-by "the association between (the knowledge about) something an expression of a work of knowledge that has that something as a subject")
ObjectPropertyRange(know:represented-by know:KnowledgeExpression)

# Object Property: know:reproduced-by (know:reproduced-by)

SubObjectPropertyOf(know:reproduced-by know:carried-by)
InverseObjectProperties(know:reproduced-by know:reproduces)
ObjectPropertyDomain(know:reproduced-by know:KnowledgeExpression)
ObjectPropertyRange(know:reproduced-by know:KnowledgeArtifact)

# Object Property: know:reproduces (know:reproduces)

SubObjectPropertyOf(know:reproduces know:carries)
ObjectPropertyDomain(know:reproduces know:KnowledgeArtifact)
ObjectPropertyRange(know:reproduces know:KnowledgeExpression)

# Object Property: know:serialization-of (is concrete representation of)

AnnotationAssertion(rdfs:label know:serialization-of "is concrete representation of"@en)
InverseObjectProperties(know:serialization-of know:serialized-into)
ObjectPropertyDomain(know:serialization-of know:ConcreteExpression)
ObjectPropertyRange(know:serialization-of know:AbstractExpression)

# Object Property: know:serialized-into (concretely represented as)

AnnotationAssertion(rdfs:label know:serialized-into "concretely represented as"@en)
AnnotationAssertion(skos:altLabel know:serialized-into "has concretization")
ObjectPropertyDomain(know:serialized-into know:AbstractExpression)
ObjectPropertyRange(know:serialized-into know:ConcreteExpression)

# Object Property: know:serializes (serializes)

AnnotationAssertion(rdfs:label know:serializes "serializes"@en)
AnnotationAssertion(skos:definition know:serializes "The relation between the concrete syntax of a language and that language")
InverseObjectProperties(know:serializes know:supports-serialization)
ObjectPropertyDomain(know:serializes know:Serialization)
ObjectPropertyRange(know:serializes know:Language)

# Object Property: know:specified-by (specified by)

AnnotationAssertion(rdfs:label know:specified-by "specified by")
AnnotationAssertion(skos:definition know:specified-by "The relationship between Something and its specification - a (prescriptive) expression of a work of knowledge that defines how that something should behave")
SubObjectPropertyOf(know:specified-by know:represented-by)
ObjectPropertyRange(know:specified-by know:AbstractExpression)

# Object Property: know:stored-in (stored in)

AnnotationAssertion(rdfs:label know:stored-in "stored in")
AnnotationAssertion(skos:definition know:stored-in "an artifact (as a carrier of the expression of a piece of knowledge) is stored in a container that has the function of a knowledge repository")
InverseObjectProperties(know:stored-in know:stores)
ObjectPropertyDomain(know:stored-in know:KnowledgeEndeavour)

# Object Property: know:stores (stores)

AnnotationAssertion(rdfs:label know:stores "Notice that only Artifacts can be stored in practice. Storing a Work or an Expression implies the existence of an Artifact that carries (the Expression that realized) that Work. 
Nevertheless, the relationship can be asserted at any level, to shift the focus on the entity that is valuable for the purpose of storage")
AnnotationAssertion(rdfs:label know:stores "stores")
AnnotationAssertion(skos:definition know:stores "the relationship between an entity with the function of Knowledge artifact repository, and the knowledge resources that are stored therein by means of some carrier.

An entity stores a Work, Expression or Artifact if it is able to keep (a copy of) it, and make it accessible for use as needed")
ObjectPropertyRange(know:stores know:KnowledgeEndeavour)

# Object Property: know:supports-expression (supports expression in)

AnnotationAssertion(rdfs:comment know:supports-expression "In order to be useful, the supported notations should be able to structure most sentences of the language.")
AnnotationAssertion(rdfs:label know:supports-expression "supports expression in")
AnnotationAssertion(skos:definition know:supports-expression "A Language L supports an Abstract Syntax S if there exists at least one sentence in the extension of L, such that an AST based on S can be built for that sentence")
ObjectPropertyDomain(know:supports-expression know:Language)
ObjectPropertyRange(know:supports-expression know:AbstractSyntax)

# Object Property: know:supports-serialization (supports serialization in)

AnnotationAssertion(rdfs:label know:supports-serialization "supports serialization in"@en)
AnnotationAssertion(skos:definition know:supports-serialization "A Language L supports a Concrete Syntax S if there exists at least one sentence in the language that S formalizes, such that a parse tree can be constructed out of the tokens that form that sentence")
ObjectPropertyDomain(know:supports-serialization know:Language)
ObjectPropertyRange(know:supports-serialization know:Serialization)

# Object Property: know:targets (targets)

AnnotationAssertion(rdfs:label know:targets "targets")
AnnotationAssertion(skos:definition know:targets "an activity targets  a (passive) participant, which is pre-existing to the start of the activity, but is changed somehow in the process. 
i.e.the activity does not alter any of the essential qualities that define the identity of the entity, but results in some change to the non-essential ones.")
SubObjectPropertyOf(know:targets know:involves)
ObjectPropertyDomain(know:targets know:Activity)

# Object Property: know:unambiguously-expresses (unambiguously expresses)

AnnotationAssertion(rdfs:label know:unambiguously-expresses "unambiguously expresses")
AnnotationAssertion(skos:definition know:unambiguously-expresses "every element in the expression has no more than one possible conceptualization")
SubObjectPropertyOf(know:unambiguously-expresses know:expresses)

# Object Property: know:used-in (used in)

AnnotationAssertion(rdfs:label know:used-in "used in")
SubObjectPropertyOf(know:used-in know:involved-in)
ObjectPropertyRange(know:used-in know:Activity)

# Object Property: know:uses-annotation-language (uses annotation language)

AnnotationAssertion(rdfs:label know:uses-annotation-language "uses annotation language")
AnnotationAssertion(skos:definition know:uses-annotation-language "The relationship between an expression and the language used to annotate the expression, i.e. to express fragments that are not essential to the conceptualization of the expression")
SubObjectPropertyOf(know:uses-annotation-language know:uses-as-sublanguage)
ObjectPropertyDomain(know:uses-annotation-language know:KnowledgeExpression)
ObjectPropertyRange(know:uses-annotation-language know:Language)

# Object Property: know:uses-as-sublanguage (uses as sub-language)

AnnotationAssertion(rdfs:label know:uses-as-sublanguage "uses as sub-language")
AnnotationAssertion(skos:definition know:uses-as-sublanguage "an Expression E uses L as a sublanguage if
 - L is not the primary language
 - there exists at least one sub-tree of E's AST such that that sub-tree formalizes a valid expression of L")
SubObjectPropertyOf(know:uses-as-sublanguage know:uses-language)
ObjectPropertyDomain(know:uses-as-sublanguage know:KnowledgeExpression)
ObjectPropertyRange(know:uses-as-sublanguage know:Language)

# Object Property: know:uses-concept (uses concept)

AnnotationAssertion(rdfs:label know:uses-concept "uses concept")
AnnotationAssertion(skos:definition know:uses-concept "a work of knowledge uses a concept if the concept is part of the concepts selected during the creation of the work, and thus is part of the work")
SubObjectPropertyOf(know:uses-concept know:has-part)
ObjectPropertyDomain(know:uses-concept know:WorkOfKnowledge)
ObjectPropertyRange(know:uses-concept know:AtomicConcept)

# Object Property: know:uses-concrete-syntax (uses concrete syntax)

AnnotationAssertion(rdfs:label know:uses-concrete-syntax "uses concrete syntax"@en)
AnnotationAssertion(skos:altLabel know:uses-concrete-syntax "The relationship between a Concrete Expression and the concrete syntax used to serialize its abstract form")
AnnotationAssertion(skos:altLabel know:uses-concrete-syntax "uses format")
AnnotationAssertion(skos:altLabel know:uses-concrete-syntax "uses serialization")
ObjectPropertyDomain(know:uses-concrete-syntax know:ConcreteExpression)
ObjectPropertyRange(know:uses-concrete-syntax know:Serialization)

# Object Property: know:uses-language (uses language)

AnnotationAssertion(rdfs:label know:uses-language "uses language")
AnnotationAssertion(skos:definition know:uses-language "The relationship between an Expression (abstract or concrete) and the Language used to express it.

(A concrete expression that is a concrete representation of) an Abstract Expression uses a language if itself, or a fragment thereof, uses a Notation that formalizes the Language, i.e. the expression conforms to the rules defined by the Notation.")
ObjectPropertyDomain(know:uses-language know:KnowledgeExpression)
ObjectPropertyRange(know:uses-language know:Language)

# Object Property: know:uses-lexicon (uses lexicon)

AnnotationAssertion(rdfs:label know:uses-lexicon "uses lexicon")
AnnotationAssertion(skos:definition know:uses-lexicon "The relationship between a knowledge expresison and the lexicon from which its actual linguistic elements (aka signature) are extracted")
ObjectPropertyDomain(know:uses-lexicon know:KnowledgeExpression)
ObjectPropertyRange(know:uses-lexicon know:Lexicon)

# Object Property: know:uses-primary-language (uses primary language)

AnnotationAssertion(rdfs:comment know:uses-primary-language "In case of set-oriented structured resources, it is sufficient that at least one of the member resources uses L as primary language")
AnnotationAssertion(rdfs:label know:uses-primary-language "uses primary language")
AnnotationAssertion(skos:definition know:uses-primary-language "An Expression E uses L as primary language if there exists a sub-tree S of E's AST T that formalizes a valid expression of L, and the root of S coincides with the root of T.")
SubObjectPropertyOf(know:uses-primary-language know:uses-language)
ObjectPropertyDomain(know:uses-primary-language know:KnowledgeExpression)
ObjectPropertyRange(know:uses-primary-language know:Language)

# Object Property: know:uses-profile (uses profile)

AnnotationAssertion(rdfs:label know:uses-profile "uses profile")
AnnotationAssertion(skos:definition know:uses-profile "The relationship between a Knowledge Expression and a profile of an (abstract) syntax that it conforms to")
SubObjectPropertyOf(know:uses-profile know:uses-syntax)
ObjectPropertyDomain(know:uses-profile know:KnowledgeExpression)
ObjectPropertyRange(know:uses-profile know:Profile)

# Object Property: know:uses-syntax (uses syntax)

AnnotationAssertion(rdfs:label know:uses-syntax "uses syntax")
AnnotationAssertion(skos:definition know:uses-syntax "An expression uses a syntax if it is (known to have been originally) formulated according to that syntax.")
AnnotationAssertion(skos:scopeNote know:uses-syntax "Using a syntax implies conformance to that syntax. The converse is not true in general: a sentence written in a language may still be valid according to the rules of another language it is checked against. 
This is necessarily true when the former language is embedded in the latter, but may also be coincidentally true (e.g. the sentence \"3+5\" conforms to the syntax of many programming languages).")
SubObjectPropertyOf(know:uses-syntax know:conforms-with)
ObjectPropertyDomain(know:uses-syntax know:KnowledgeExpression)
ObjectPropertyRange(know:uses-syntax know:AbstractSyntax)



############################
#   Classes
############################

# Class: know:AbstractExpression (abstract knowledge expression)

AnnotationAssertion(rdfs:comment know:AbstractExpression "Abstract expressions, by definition generically depend on some carrier. An abstract expression needs one to exist physically, but does not depend on any particular one. Abstract Expressions, however, cannot be realized directly. The language needs to be complemented with a ‘form’ that allows for a concrete syntactic encoding (e.g. written vs vocal for English, XML vs JSON for UML Class Models, OFN vs Turtle for OWL, etc..)")
AnnotationAssertion(rdfs:comment know:AbstractExpression "An Abstract Knowledge Expression can be internally represented by an Agent in terms of an Abstract Syntax Tree")
AnnotationAssertion(rdfs:label know:AbstractExpression "abstract knowledge expression"@en)
AnnotationAssertion(rdfs:seeAlso know:AbstractExpression know:AbstractSyntax)
AnnotationAssertion(rdfs:seeAlso know:AbstractExpression know:Serialization)
AnnotationAssertion(skos:definition know:AbstractExpression "The class of equivalence of Concrete Expressions of some Knowledge content, in some Language, across the various serializations supported by that language.")
SubClassOf(know:AbstractExpression know:KnowledgeExpression)
SubClassOf(know:AbstractExpression ObjectSomeValuesFrom(know:knowledge-representation-of know:PieceOfKnowledge))
SubClassOf(know:AbstractExpression ObjectSomeValuesFrom(know:serialized-into know:ConcreteExpression))
DisjointClasses(know:AbstractExpression know:ConcreteExpression)

# Class: know:AbstractSyntax (abstract syntax)

AnnotationAssertion(rdfs:comment know:AbstractSyntax "Like all Abstract Expressions, it needs a serialization to be concretized")
AnnotationAssertion(rdfs:label know:AbstractSyntax "abstract syntax"@en)
AnnotationAssertion(skos:definition know:AbstractSyntax "The set of structures and/or rules that constrain the abstract syntax tree of a valid sentence of a language, itself expressed in some (meta) language")
SubClassOf(know:AbstractSyntax know:Syntax)
DisjointClasses(know:AbstractSyntax know:Serialization)

# Class: know:AbstractSyntaxTree (abstract syntax tree)

AnnotationAssertion(rdfs:label know:AbstractSyntaxTree "AST")
AnnotationAssertion(rdfs:label know:AbstractSyntaxTree "abstract syntax tree")
AnnotationAssertion(skos:definition know:AbstractSyntaxTree "The representation of the internal structure of an Abstract Expression, according to some Abstract Syntax, obtained from the parsing of a Concrete Expression of which that Abstract Expression is a concrete representation")
SubClassOf(know:AbstractSyntaxTree know:AbstractExpression)
SubClassOf(know:AbstractSyntaxTree ObjectSomeValuesFrom(know:formalizes ObjectSomeValuesFrom(know:has-subject know:AbstractExpression)))

# Class: know:Activity (activity)

AnnotationAssertion(rdfs:comment know:Activity "This classes is provided for compatibility with other ontologies that define 'Activity' at higher levels of abstraction and/or generality")
AnnotationAssertion(rdfs:label know:Activity "activity")
AnnotationAssertion(skos:definition know:Activity "An intentional process, executed with the active participation of one of more Agents that carry out a plan..")

# Class: know:Agent (agent)

AnnotationAssertion(rdfs:comment know:Agent "Agents can act on behalf of other Agents, or do so as a consequence of a speech act (request, command, suggestion, etc..)")
AnnotationAssertion(rdfs:comment know:Agent "Some agents have intentions, and can decide to act based on them")
AnnotationAssertion(rdfs:label know:Agent "agent")
AnnotationAssertion(skos:definition know:Agent "Any entity that has the capability (potential) to be an active participant in an Activity")
AnnotationAssertion(skos:scopeNote know:Agent "This abstract definition of Agent is intended to be as broad as possible, at least covering human and software agents alike. It is also meant to include individual agents, as well as collectives thereof.
The intent is to be refined/redefined/concretized when this ontology is used in conjunction with another ontology of social aspects.")

# Class: know:AgentiveRole (agentive role)

AnnotationAssertion(rdfs:label know:AgentiveRole "active paticipant (type)")
AnnotationAssertion(rdfs:label know:AgentiveRole "agentive role")
AnnotationAssertion(skos:definition know:AgentiveRole "concept that archetypes an Agent, and whose definition specifies how it participates (actively) in some Activity")
EquivalentClasses(know:AgentiveRole ObjectIntersectionOf(know:DefinedConcept ObjectSomeValuesFrom(know:archetypes know:Agent)))
SubClassOf(know:AgentiveRole know:DefinedConcept)
DisjointClasses(know:AgentiveRole know:PassiveRole)

# Class: know:ArtificialAgent (artificial agent)

AnnotationAssertion(rdfs:label know:ArtificialAgent "artificial agent")
SubClassOf(know:ArtificialAgent know:Agent)
SubClassOf(know:ArtificialAgent ObjectSomeValuesFrom(know:product-of know:Activity))

# Class: know:AtomicConcept (concept)

AnnotationAssertion(rdfs:comment know:AtomicConcept "Individual concepts - instances of this class - are universals whose extension can be formally expressed (in OWL) by means of an OWL class, which represents the set of all past, present and future particular individuals that can be classified by the concept")
AnnotationAssertion(rdfs:comment know:AtomicConcept "This notion of Concept is defined as a generically dependent continuant which, consistently with its semiotic interpretation, is 'about' some referent.

It is considered a 'unit of knowledge', or 'unit of (conceptual) representation'.  

The corresponding notion of a specifically dependent continuant - i.e. the concept that one specific agent has of a given refernet - is better defined as a 'unit of thought'.")
AnnotationAssertion(rdfs:label know:AtomicConcept "concept")
AnnotationAssertion(skos:altLabel know:AtomicConcept "representational unit")
AnnotationAssertion(skos:definition know:AtomicConcept "An atomic piece of knowledge that can be used for the construction of more complex pieces of knowledge")
SubClassOf(know:AtomicConcept know:PieceOfKnowledge)

# Class: know:ComplexConcept (complex concept)

AnnotationAssertion(rdfs:comment know:ComplexConcept "When expressed in OWL, complex concepts are described in terms of their relationships to other concepts, using subClassOf or equivalentClass axioms")
AnnotationAssertion(rdfs:label know:ComplexConcept "complex concept")
AnnotationAssertion(skos:definition know:ComplexConcept "A Concept that can be decomposed into a complex association of other Concepts, ans such that there is at least one Work of Knowledge that captures those Concepts and their relationships")
EquivalentClasses(know:ComplexConcept ObjectIntersectionOf(know:AtomicConcept ObjectSomeValuesFrom(know:captured-by know:WorkOfKnowledge)))
SubClassOf(know:ComplexConcept know:AtomicConcept)

# Class: know:CompositeKnowledgeResource (Composite Knowledge Resource)

AnnotationAssertion(rdfs:comment know:CompositeKnowledgeResource "Functionally Complex Resource that has one or more structural components, and provides the structuring for them. Each component plays a specific role")
AnnotationAssertion(rdfs:label know:CompositeKnowledgeResource "Composite Knowledge Resource"@en)
AnnotationAssertion(skos:definition know:CompositeKnowledgeResource "A Composite Knowledge Resource is a Structured Knowledge Resource such that the structuring operation preserved the original components, allowing to discern them.")
SubClassOf(know:CompositeKnowledgeResource know:StructuredKnowledgeResource)

# Class: know:ComputableLanguage (computable language)

AnnotationAssertion(rdfs:label know:ComputableLanguage "computable language"@en)
AnnotationAssertion(skos:definition know:ComputableLanguage "Constructed Language that is used only by expressions that define how to execute information processing tasks and, as such, is indirectly used in certain Information Processing Activities")
SubClassOf(know:ComputableLanguage know:ConstructedLanguage)
SubClassOf(know:ComputableLanguage ObjectSomeValuesFrom(ObjectInverseOf(know:uses-language) ObjectSomeValuesFrom(ObjectInverseOf(know:specified-by) know:InformationProcessingActivity)))

# Class: know:ConcreteExpression (concrete knowledge expression)

AnnotationAssertion(rdfs:comment know:ConcreteExpression "A concrete expression is the result of the act of serializing an (abstract) expression using a concrete syntax, which adds 'form' aspects that allow to engrave an encoding of the expression on a carrier")
AnnotationAssertion(rdfs:comment know:ConcreteExpression "As a remark, two individual Concrete Expressions of the same Abstract Expression (of the same Work) are different if they use different serializations")
AnnotationAssertion(rdfs:label know:ConcreteExpression "concrete knowledge expression"@en)
AnnotationAssertion(skos:definition know:ConcreteExpression "An Expression in some language, serialized using one of the concrete syntaxes supported by that language")
SubClassOf(know:ConcreteExpression know:KnowledgeExpression)
SubClassOf(know:ConcreteExpression ObjectSomeValuesFrom(know:serialization-of know:AbstractExpression))
SubClassOf(know:ConcreteExpression ObjectSomeValuesFrom(know:uses-concrete-syntax know:Serialization))

# Class: know:ConstructedLanguage (constructed language)

AnnotationAssertion(rdfs:label know:ConstructedLanguage "constructed language")
AnnotationAssertion(skos:definition know:ConstructedLanguage "Languages that are intensionally specified by a formal grammar, schema or metamodel - a set of criteria (e.g. rules and constraints) explicitly designed to distinguish valid sentences from invalid ones in a non-ambiguous way")
EquivalentClasses(know:ConstructedLanguage ObjectIntersectionOf(know:Language ObjectSomeValuesFrom(know:specified-by ObjectIntersectionOf(know:Syntax ObjectSomeValuesFrom(know:formalizes ObjectIntersectionOf(know:FormalGrammar know:PrescriptiveGrammar))))))

# Class: know:ConstructiveDefinition (constructive definition)

AnnotationAssertion(rdfs:label know:ConstructiveDefinition "constructive definition")
AnnotationAssertion(skos:definition know:ConstructiveDefinition "definition that can be used to generate instances of a concept, as well as recognizing them")
SubClassOf(know:ConstructiveDefinition know:Definition)

# Class: know:ControlledNaturalLanguage (controlled natural language)

AnnotationAssertion(rdfs:label know:ControlledNaturalLanguage "controlled natural language")
AnnotationAssertion(skos:definition know:ControlledNaturalLanguage "Subset of a Natural Language that has a formal grammar constructed in a way to simplify and/or disambiguate that natural language")
SubClassOf(know:ControlledNaturalLanguage know:ConstructedLanguage)
SubClassOf(know:ControlledNaturalLanguage know:NaturalLanguage)

# Class: know:DefinedConcept (defined concept)

AnnotationAssertion(rdfs:comment know:DefinedConcept "When expressed in OWL, defined concepts have at least one equivalentClass axiom, assuming OWL is sufficiently expressive to represent that definition.")
AnnotationAssertion(rdfs:label know:DefinedConcept "defined concept")
AnnotationAssertion(skos:definition know:DefinedConcept "A concept that has at least one explicit definition")
EquivalentClasses(know:DefinedConcept ObjectIntersectionOf(know:ComplexConcept ObjectSomeValuesFrom(know:defined-by know:Definition)))
SubClassOf(know:DefinedConcept know:ComplexConcept)

# Class: know:Definition (definition)

AnnotationAssertion(rdfs:comment know:Definition "a definition is associated to a concept that is (implicitly) defined by the definition itself")
AnnotationAssertion(rdfs:label know:Definition "definition")
AnnotationAssertion(skos:definition know:Definition "a work of knowledge that captures necessary and sufficient conditions to recognize something")
SubClassOf(know:Definition know:WorkOfKnowledge)
SubClassOf(know:Definition ObjectSomeValuesFrom(know:defines know:DefinedConcept))

# Class: know:DescriptiveGrammar (descriptive grammar)

AnnotationAssertion(rdfs:label know:DescriptiveGrammar "descriptive grammar")
AnnotationAssertion(rdfs:seeAlso know:DescriptiveGrammar "https://www.teachingenglish.org.uk/article/descriptive-grammar")
AnnotationAssertion(skos:definition know:DescriptiveGrammar "a grammar that documents how a language is actually used")
SubClassOf(know:DescriptiveGrammar know:Grammar)

# Class: know:EncodedKnowledgeExpression (encoded knowledge expression)

AnnotationAssertion(rdfs:label know:EncodedKnowledgeExpression "encoded knowledge expression")
SubClassOf(know:EncodedKnowledgeExpression know:KnowledgeExpression)

# Class: know:Encoding (encoding)

AnnotationAssertion(rdfs:label know:Encoding "encoding")
AnnotationAssertion(rdfs:seeAlso know:Encoding "https://en.wikipedia.org/wiki/Code")
AnnotationAssertion(rdfs:seeAlso know:Encoding "https://en.wikipedia.org/wiki/Encoding_(memory)")
AnnotationAssertion(skos:definition know:Encoding "method for converting a concrete (knowledge) expression into a from that is suitable to be engraved on a carrier of choice")
SubClassOf(know:Encoding know:KnowledgeProcessingMethod)

# Class: know:FormalGrammar (formal grammar)

AnnotationAssertion(rdfs:label know:FormalGrammar "formal grammar")
AnnotationAssertion(skos:definition know:FormalGrammar "A grammar such there exists at least one syntax that uses a formal language and is a faithful expression of that grammar")
EquivalentClasses(know:FormalGrammar ObjectIntersectionOf(know:Grammar ObjectSomeValuesFrom(know:conceptualizes ObjectIntersectionOf(know:Syntax ObjectSomeValuesFrom(know:uses-language know:FormalLanguage)))))
SubClassOf(know:FormalGrammar know:Grammar)

# Class: know:FormalLanguage (formal logic language)

AnnotationAssertion(rdfs:label know:FormalLanguage "formal logic language"@en)
AnnotationAssertion(skos:definition know:FormalLanguage "language equipped with a formal, declarative, logic-based semantics")
SubClassOf(know:FormalLanguage know:ConstructedLanguage)

# Class: know:Grammar (grammar)

AnnotationAssertion(rdfs:comment know:Grammar "If a grammar X formalizes a Language L, and X is expressed by an abstract syntax S, L is 'specified by' S.")
AnnotationAssertion(rdfs:comment know:Grammar "Language Specifications are expressed by syntaxes and realized by (formal) grammars")
AnnotationAssertion(rdfs:label know:Grammar "grammar")
AnnotationAssertion(skos:altLabel know:Grammar "Combinatorial Information Encoding System")
AnnotationAssertion(skos:definition know:Grammar "A conceptualization of the set of rules and constraints that define (the valid sentences of) a language")
EquivalentClasses(know:Grammar ObjectIntersectionOf(know:WorkOfKnowledge ObjectSomeValuesFrom(know:captures know:Language)))
SubClassOf(know:Grammar know:WorkOfKnowledge)
SubClassOf(know:Grammar ObjectSomeValuesFrom(know:conceptualizes know:Syntax))

# Class: know:Identifier (identifier)

AnnotationAssertion(rdfs:label know:Identifier "identifier")
AnnotationAssertion(skos:definition know:Identifier "Identifers are resolved to exactly 1 entity, and express the concept that abstracts that entity")
SubClassOf(know:Identifier know:KnowledgeElement)

# Class: know:InformationProcessingActivity (information processing activity)

AnnotationAssertion(rdfs:label know:InformationProcessingActivity "information processing activity")
AnnotationAssertion(skos:definition know:InformationProcessingActivity "activity that has at least one information object as input")
SubClassOf(know:InformationProcessingActivity know:Activity)

# Class: know:IntellectualWork (intellectual work)

AnnotationAssertion(rdfs:comment know:IntellectualWork "Initially, it generically depends on some Agent, that carries its internal representation, until it can be carried by a concrete manifestation and possibly assimilated by other Agents.")
AnnotationAssertion(rdfs:comment know:IntellectualWork "Semiotically, an Intellectual Work is situated at the Meaning level: It needs to be expressed (and carried by a medium) in order to be communicated")
AnnotationAssertion(rdfs:label know:IntellectualWork "intellectual work"@en)
AnnotationAssertion(skos:definition know:IntellectualWork "The conceptual outcome of an intellectual creative activity. It has as a subject, and thus is about, some kind of Thing (e.g. idea, person, place, etc..).")
SubClassOf(know:IntellectualWork know:KnowledgeEndeavour)

# Class: know:Knowledge (knowledge)

AnnotationAssertion(rdfs:label know:Knowledge "knowledge"@en)
AnnotationAssertion(skos:definition know:Knowledge "The cognition (know-what), pragmatics (know-how) and understanding (know-why) - about the nature and/or behaviour of some Thing")
SubClassOf(know:Knowledge ObjectSomeValuesFrom(know:is-about owl:Thing))

# Class: know:KnowledgeActivity (knowledge processing activity)

AnnotationAssertion(rdfs:label know:KnowledgeActivity "knowledge processing activity")
AnnotationAssertion(skos:definition know:KnowledgeActivity "Any Activity that involves the participation of a Knowledge Carrier as a product, tool, aid or background resource. The Knowledge Carrier carries the Knowledge which plays the role of information object in this context")
EquivalentClasses(know:KnowledgeActivity ObjectIntersectionOf(know:InformationProcessingActivity ObjectSomeValuesFrom(know:involves know:KnowledgeCarrier)))

# Class: know:KnowledgeArtifact (knowledge artifact)

AnnotationAssertion(rdfs:comment know:KnowledgeArtifact "As a concrete information carrier, it is expressed in some language, using a concrete notation, and is an exemplar of the class of artifacts that corresponds to a specific type of Manifestation")
AnnotationAssertion(rdfs:label know:KnowledgeArtifact "knowledge artifact"@en)
AnnotationAssertion(rdfs:label know:KnowledgeArtifact "material knowledge carrier")
AnnotationAssertion(skos:definition know:KnowledgeArtifact "A digital or physical object that carries (copy of) one or more serialized Knowledge Resources.")
AnnotationAssertion(skos:scopeNote know:KnowledgeArtifact "In FRBR, classes of artifacts are defined intensionally, using 'universals' ('species') which are themselves instances of the class Manifestation.

In OWL-DL, it is not possible to express at the same time the extensional definition (different subclasses of Knowledge Artifact) and its intensional counterpart (different individuals, instances of Manifestation), other than using punning. For this reason, the notion of Manifestation is not explicitly modelled")
SubClassOf(know:KnowledgeArtifact know:KnowledgeCarrier)
SubClassOf(know:KnowledgeArtifact ObjectSomeValuesFrom(know:product-of know:Activity))

# Class: know:KnowledgeArtifactRepository (knowledge artifact repository)

AnnotationAssertion(rdfs:label know:KnowledgeArtifactRepository "knowledge artifact repository")
SubClassOf(know:KnowledgeArtifactRepository know:KnowledgeProcessingFunction)
SubClassOf(know:KnowledgeArtifactRepository ObjectSomeValuesFrom(know:function-of ObjectSomeValuesFrom(know:stores know:KnowledgeArtifact)))

# Class: know:KnowledgeAssetSurrogate (knowledge asset surrogate)

AnnotationAssertion(rdfs:label know:KnowledgeAssetSurrogate "knowledge asset surrogate"@en)
AnnotationAssertion(skos:definition know:KnowledgeAssetSurrogate "A Knowledge Artifact that carries the serialization of a Knowledge Resource Description")
EquivalentClasses(know:KnowledgeAssetSurrogate ObjectIntersectionOf(know:KnowledgeArtifact ObjectSomeValuesFrom(know:carries ObjectIntersectionOf(know:ConcreteExpression ObjectSomeValuesFrom(know:serialization-of know:KnowledgeResourceDescription)))))

# Class: know:KnowledgeCarrier (knowledge carrier)

AnnotationAssertion(rdfs:label know:KnowledgeCarrier "knowledge carrier")
AnnotationAssertion(skos:definition know:KnowledgeCarrier "The medium that supoprts an engraving of (an encoding of) a concrete, serialized knowledge expression")
AnnotationAssertion(skos:scopeNote know:KnowledgeCarrier "From the perspective of an agent, this class includes external carriers, such as documents and files, as well as internal carriers, such as neural patterns and/or digital memories")
SubClassOf(know:KnowledgeCarrier know:KnowledgeEndeavour)
SubClassOf(know:KnowledgeCarrier ObjectSomeValuesFrom(know:carries ObjectIntersectionOf(know:ConcreteExpression ObjectSomeValuesFrom(know:representation-of know:PieceOfKnowledge))))

# Class: know:KnowledgeConstructionActivity (knowledge construction activity)

AnnotationAssertion(rdfs:label know:KnowledgeConstructionActivity "knowledge construction activity")
AnnotationAssertion(skos:definition know:KnowledgeConstructionActivity "the class of activities that involve structured knowledge resources")
EquivalentClasses(know:KnowledgeConstructionActivity ObjectIntersectionOf(know:KnowledgeActivity ObjectSomeValuesFrom(know:involves know:StructuredKnowledgeResource)))
SubClassOf(know:KnowledgeConstructionActivity know:KnowledgeActivity)

# Class: know:KnowledgeElement (knowledge expression element)

AnnotationAssertion(rdfs:label know:KnowledgeElement "knowledge expression element")
AnnotationAssertion(rdfs:seeAlso know:KnowledgeElement "http://www.w3.org/ns/lemon/ontolex#LexicalEntry")
AnnotationAssertion(skos:definition know:KnowledgeElement "fragment that expresses exactly one concept")
AnnotationAssertion(skos:note know:KnowledgeElement "knowledge expression elements are the leaves of an expression's AST, and as such are derived from (a subset of) the tokens into which a concrete expression is broken during its parsing.")
SubClassOf(know:KnowledgeElement know:KnowledgeFragment)
SubClassOf(know:KnowledgeElement ObjectExactCardinality(1 know:expresses know:AtomicConcept))

# Class: know:KnowledgeEndeavour (knowledge endeavour)

AnnotationAssertion(rdfs:label know:KnowledgeEndeavour "knowledge endeavour")
AnnotationAssertion(skos:definition know:KnowledgeEndeavour "Endurant that embeds, directly or indirectly, some Piece of Knowledge")

# Class: know:KnowledgeExpression (knowledge expression)

AnnotationAssertion(rdfs:comment know:KnowledgeExpression "Expressions can be abstract or concrete, depending on their conformance to the constraints that specify either an abstract, as opposed to a concrete, syntax for the language used to express the Work")
AnnotationAssertion(rdfs:label know:KnowledgeExpression "knowledge expression"@en)
AnnotationAssertion(skos:definition know:KnowledgeExpression "The expression of a Work, constrained by an information encoding system such as the abstract syntax of a grammar, a schema or a (meta)model")
SubClassOf(know:KnowledgeExpression know:KnowledgeEndeavour)
SubClassOf(know:KnowledgeExpression ObjectSomeValuesFrom(know:uses-language know:Language))
SubClassOf(know:KnowledgeExpression ObjectSomeValuesFrom(know:uses-syntax know:AbstractSyntax))
DisjointUnion(know:KnowledgeExpression know:AbstractExpression know:ConcreteExpression)

# Class: know:KnowledgeFragment (knowledge fragment)

AnnotationAssertion(rdfs:comment know:KnowledgeFragment "Fragments express proper parts of a Work of Knowledge")
AnnotationAssertion(rdfs:label know:KnowledgeFragment "knowledge fragment")
AnnotationAssertion(skos:altLabel know:KnowledgeFragment "Knowledge Resource Fragment")
AnnotationAssertion(skos:altLabel know:KnowledgeFragment "knowledge resource fragment")
AnnotationAssertion(skos:definition know:KnowledgeFragment "A proper part of a Knowledge Resource that is not a Resource itself")
EquivalentClasses(know:KnowledgeFragment ObjectIntersectionOf(know:AbstractExpression ObjectSomeValuesFrom(know:proper-part-of know:KnowledgeResource)))
SubClassOf(know:KnowledgeFragment know:AbstractExpression)
SubClassOf(know:KnowledgeFragment ObjectSomeValuesFrom(know:expresses ObjectSomeValuesFrom(know:proper-part-of know:WorkOfKnowledge)))
SubClassOf(know:KnowledgeFragment ObjectSomeValuesFrom(know:knowledge-representation-of ObjectComplementOf(know:WorkOfKnowledge)))

# Class: know:KnowledgeManifestation (knowledge manifestation)

AnnotationAssertion(rdfs:comment know:KnowledgeManifestation "All the exemplars of a given manifestation are copies (replicas) of each other. Conversely, given an exemplar of a manifestation, if that exemplar is copied (replicated), the copy will be an exemplar of the same manifestation")
AnnotationAssertion(rdfs:comment know:KnowledgeManifestation "The original exemplar is called a 'master copy'")
AnnotationAssertion(rdfs:label know:KnowledgeManifestation "knowledge manifestation")
AnnotationAssertion(skos:definition know:KnowledgeManifestation "The archetype of a class of knowledge artifacts, defining the common qualities - including the concrete expression(s) carried by the artifacts, and the form used to encode and engrave the expression in the artifact")
SubClassOf(know:KnowledgeManifestation know:DefinedConcept)
SubClassOf(know:KnowledgeManifestation ObjectSomeValuesFrom(know:archetypes know:KnowledgeCarrier))

# Class: know:KnowledgeProcessingFunction ((knowledge processing) function)

AnnotationAssertion(rdfs:comment know:KnowledgeProcessingFunction "in general: \"the purpose for which something is designed or exists\"")
AnnotationAssertion(rdfs:label know:KnowledgeProcessingFunction "(knowledge processing) function")
AnnotationAssertion(skos:definition know:KnowledgeProcessingFunction "concept that defines the purpose on an entity, manifested as it plays a certain role and realized through the execution of certain tasks")
AnnotationAssertion(skos:scopeNote know:KnowledgeProcessingFunction "this class is intended to be limited to functions regarding the processing of knowledge. As such it should always be narrower than the general notion of 'function' usually defined in upper ontologies")
SubClassOf(know:KnowledgeProcessingFunction know:DefinedConcept)
SubClassOf(know:KnowledgeProcessingFunction ObjectSomeValuesFrom(know:associated-to know:KnowledgeProcessingTask))
SubClassOf(know:KnowledgeProcessingFunction ObjectSomeValuesFrom(know:associated-to ObjectUnionOf(know:AgentiveRole know:PassiveRole)))

# Class: know:KnowledgeProcessingMethod (knowledge processing method)

AnnotationAssertion(rdfs:label know:KnowledgeProcessingMethod "knowledge processing method")
AnnotationAssertion(skos:definition know:KnowledgeProcessingMethod "the conceptual definition of a procedure, technique or way of processing knowledge (in a broad sense)")
AnnotationAssertion(skos:scopeNote know:KnowledgeProcessingMethod "From an API4KP perspective, this class is meant to be specialzied by methods of processing knowledge, either by syntactic, semantic or pragmatic manipulation")
SubClassOf(know:KnowledgeProcessingMethod know:Definition)

# Class: know:KnowledgeProcessingPlan (knowledge processing plan)

AnnotationAssertion(rdfs:comment know:KnowledgeProcessingPlan "process plans can be imperative or adaptive, descriptive or prescriptive.

As constructive definitions, they can be used to recognize activities from a given trace, or as specifications for the execution of future activities")
AnnotationAssertion(rdfs:label know:KnowledgeProcessingPlan "knowledge processing plan")
AnnotationAssertion(skos:altLabel know:KnowledgeProcessingPlan "structured process plan")
AnnotationAssertion(skos:definition know:KnowledgeProcessingPlan "the definition of the tasks that are necessary (and possibly sufficient) to perform an activity of a given kind, in order to achieve some goals, possibly with more or less prescriptive constraints e.g. on the (relative) ordering, roles of the performers, and execution modalities")
SubClassOf(know:KnowledgeProcessingPlan know:ConstructiveDefinition)

# Class: know:KnowledgeProcessingTask ((knowledge processing) task)

AnnotationAssertion(rdfs:comment know:KnowledgeProcessingTask "Tasks can be subclassed according to the kind of methods they follow. Complex (non atomic) tasks can also be defined in terms of a plan that organizes the sub-tasks")
AnnotationAssertion(rdfs:label know:KnowledgeProcessingTask "(knowledge processing) task")
AnnotationAssertion(skos:definition know:KnowledgeProcessingTask "The conceptual abstraction of any knowledge processing activity")
AnnotationAssertion(skos:scopeNote know:KnowledgeProcessingTask "this class is intended to be limited to tasks regarding the processing of knowledge. As such it should always be narrower than the general notion of 'task' usually defined in upper ontologies")
SubClassOf(know:KnowledgeProcessingTask know:DefinedConcept)
SubClassOf(know:KnowledgeProcessingTask ObjectSomeValuesFrom(know:archetypes know:KnowledgeActivity))
SubClassOf(know:KnowledgeProcessingTask ObjectSomeValuesFrom(know:defined-by know:KnowledgeProcessingMethod))
SubClassOf(know:KnowledgeProcessingTask ObjectAllValuesFrom(know:archetypes know:KnowledgeActivity))

# Class: know:KnowledgeRepresentationAndReasoningLanguage (KRR Language)

AnnotationAssertion(rdfs:label know:KnowledgeRepresentationAndReasoningLanguage "KRR Language"@en)
AnnotationAssertion(skos:definition know:KnowledgeRepresentationAndReasoningLanguage "Language for knowledge representation and automated reasoning. 

KRR Languages are formal, and usually designed to be parsed and computed by a (running) software using tractable amounts of resources.")
AnnotationAssertion(skos:example know:KnowledgeRepresentationAndReasoningLanguage "Prolog")
EquivalentClasses(know:KnowledgeRepresentationAndReasoningLanguage ObjectIntersectionOf(know:FormalLanguage know:MachineExecutableLanguage))
SubClassOf(know:KnowledgeRepresentationAndReasoningLanguage ObjectSomeValuesFrom(ObjectInverseOf(know:uses-language) know:KnowledgeExpression))

# Class: know:KnowledgeResource (Knowledge Resource)

AnnotationAssertion(rdfs:comment know:KnowledgeResource "By definition, an information object that is about (an intellectual work that is about) some form of knowledge about something")
AnnotationAssertion(rdfs:label know:KnowledgeResource "Knowledge Resource"@en)
AnnotationAssertion(skos:definition know:KnowledgeResource "The Expression of some Work of Knowledge in the Abstract Syntax of some language")
AnnotationAssertion(skos:example know:KnowledgeResource "the specification of the allgorithm for the extraction of the square root of a number in some programming language such as Java (version 8)")
SubClassOf(know:KnowledgeResource know:AbstractExpression)
SubClassOf(know:KnowledgeResource ObjectSomeValuesFrom(know:expresses know:WorkOfKnowledge))

# Class: know:KnowledgeResourceDescription (knowledge resource description)

AnnotationAssertion(rdfs:label know:KnowledgeResourceDescription "knowledge resource description"@en)
AnnotationAssertion(skos:definition know:KnowledgeResourceDescription "Knowledge Resource that contains information (metadata) about another Resource.")
EquivalentClasses(know:KnowledgeResourceDescription ObjectIntersectionOf(know:KnowledgeResource ObjectSomeValuesFrom(know:is-about know:KnowledgeResource)))
SubClassOf(know:KnowledgeResourceDescription know:KnowledgeResource)

# Class: know:KnowledgeStructuringActivity (know:KnowledgeStructuringActivity)

SubClassOf(know:KnowledgeStructuringActivity know:KnowledgeConstructionActivity)

# Class: know:KnowledgeableAgent (knowledgeable agent)

AnnotationAssertion(rdfs:label know:KnowledgeableAgent "knowledgeable agent")
AnnotationAssertion(skos:definition know:KnowledgeableAgent "An Agent that internally represents some (piece of) Knowledge")
EquivalentClasses(know:KnowledgeableAgent ObjectIntersectionOf(know:Agent ObjectSomeValuesFrom(know:internally-represents know:Knowledge)))
SubClassOf(know:KnowledgeableAgent know:Agent)

# Class: know:Language (language)

AnnotationAssertion(rdfs:comment know:Language "Languages follow (loosely) some grammar, which specifies how to construct sentences by the combination of atomic tokens (e.g. words) from a common vocabulary.")
AnnotationAssertion(rdfs:comment know:Language "The extension of the language is the actual set of valid sentences. This notion of language 'per se', instead, captures an agent's knowledge of how to use the language to express or acquire information, including Knowledge")
AnnotationAssertion(rdfs:label know:Language "language")
AnnotationAssertion(skos:definition know:Language "The Knowledge of how to create and/or reconstruct sentences within a certain class - the class of all the possible sentences that follow the rules of the language (regardless of the existence of an explict Notation that formalizes it).")
AnnotationAssertion(skos:example know:Language "Contemporary Italian, as of 2017, as established by the Italian 'Accademia della Crusca'")
AnnotationAssertion(skos:example know:Language "The 2nd officially released version of the Ontology Web Language")
SubClassOf(know:Language know:PieceOfKnowledge)
SubClassOf(know:Language ObjectSomeValuesFrom(know:governed-by know:Grammar))
SubClassOf(know:Language ObjectSomeValuesFrom(know:has-wordstock know:Lexicon))

# Class: know:Lexicon (lexicon)

AnnotationAssertion(rdfs:label know:Lexicon "lexicon")
AnnotationAssertion(rdfs:label know:Lexicon "vocabulary")
AnnotationAssertion(rdfs:seeAlso know:Lexicon "https://en.wikipedia.org/wiki/Lexicon")
AnnotationAssertion(skos:definition know:Lexicon "Conceptual structure that organizes the lexical entries used or supported by a person, language, or branch of knowledge")
AnnotationAssertion(skos:note know:Lexicon "'Lexicon' and 'Vocabulary' are overloaded terms, whose sense is very context-specific")
SubClassOf(know:Lexicon know:PieceOfKnowledge)
SubClassOf(know:Lexicon ObjectSomeValuesFrom(know:has-part know:KnowledgeElement))

# Class: know:MachineExecutableLanguage (machine-executable language)

AnnotationAssertion(rdfs:label know:MachineExecutableLanguage "machine-executable language"@en)
AnnotationAssertion(skos:definition know:MachineExecutableLanguage "Language that can be interpreted by a machine, and the machine will be able to act based on that representation")
EquivalentClasses(know:MachineExecutableLanguage ObjectIntersectionOf(know:ComputableLanguage know:MachineReadableLanguage))
SubClassOf(know:MachineExecutableLanguage know:ComputableLanguage)

# Class: know:MachineReadableLanguage (machine-readable language)

AnnotationAssertion(rdfs:label know:MachineReadableLanguage "machine-readable language"@en)
AnnotationAssertion(skos:definition know:MachineReadableLanguage "Language such that Expressions that use it can be internally represented (i.e. parsed and interpreted) by a software at runtime")
EquivalentClasses(know:MachineReadableLanguage ObjectIntersectionOf(know:ConstructedLanguage ObjectSomeValuesFrom(know:internally-represented-by know:ArtificialAgent)))

# Class: know:Model (model)

AnnotationAssertion(rdfs:comment know:Model "TODO: Does OMG have a standard def?")
AnnotationAssertion(rdfs:label know:Model "model")
AnnotationAssertion(skos:definition know:Model "expression of knowledge about the structure (static) and/or behaviour (dynamic) of a system, constructed to emulate, study and/or predict certain aspects of that system")
SubClassOf(know:Model know:KnowledgeResource)

# Class: know:NaturalLanguage (natural language)

AnnotationAssertion(rdfs:comment know:NaturalLanguage "Includes written, oral and pictorial natural languages - differentiated by the choice of alphabet used to construct the ‘sentences’ of the languages")
AnnotationAssertion(rdfs:label know:NaturalLanguage "natural language"@en)
AnnotationAssertion(skos:definition know:NaturalLanguage "Language that is not structured. 
A language for which it is not possible to define an explicit, tractable grammar such that, for each sentence constructed out of all the possible combination of the words in that language's dictionary, always allows to distinguish and disambiguate all and only the sentences that are valid syntactically and semantically.")
EquivalentClasses(know:NaturalLanguage ObjectIntersectionOf(know:Language ObjectSomeValuesFrom(know:described-by ObjectIntersectionOf(know:Syntax ObjectSomeValuesFrom(know:expresses know:DescriptiveGrammar)))))
SubClassOf(know:NaturalLanguage know:Language)

# Class: know:Ontology (ontology)

AnnotationAssertion(rdfs:comment know:Ontology "TODO: Does OMG have a standard def?")
AnnotationAssertion(rdfs:label know:Ontology "ontology")
AnnotationAssertion(skos:definition know:Ontology "descriptive expression of knowledge about the structural, necessary aspects of a domain of interest")
SubClassOf(know:Ontology know:KnowledgeResource)

# Class: know:ParseTree (concrete syntax tree)

AnnotationAssertion(rdfs:label know:ParseTree "Parse Tree")
AnnotationAssertion(rdfs:label know:ParseTree "concrete syntax tree")
AnnotationAssertion(skos:definition know:ParseTree "The representation, in terms of a tree, of the internal structure of a Concrete (Knowledge) Expression, according to some Concrete Syntax")
SubClassOf(know:ParseTree know:AbstractExpression)
SubClassOf(know:ParseTree ObjectSomeValuesFrom(know:formalizes ObjectSomeValuesFrom(know:has-subject know:ConcreteExpression)))

# Class: know:PassiveRole (passive role)

AnnotationAssertion(rdfs:label know:PassiveRole "passive role")
AnnotationAssertion(skos:definition know:PassiveRole "Role played by an entity that participates passively in an activity, e.g. as a resource, or as the subject/target of the activity")
SubClassOf(know:PassiveRole know:DefinedConcept)

# Class: know:PieceOfKnowledge (piece of knowledge)

AnnotationAssertion(rdfs:comment know:PieceOfKnowledge "When an agent represents the complex internally, the agent possess some Knowledge (i.e. Knowledge about *some* thing)")
AnnotationAssertion(rdfs:label know:PieceOfKnowledge "piece of knowledge")
AnnotationAssertion(skos:definition know:PieceOfKnowledge "A finite, complex association of one or more Concepts, intended as generically dependent representational units.")
AnnotationAssertion(skos:example know:PieceOfKnowledge "the knowledge of how to extract the square number of a positive, integer number")
AnnotationAssertion(skos:example know:PieceOfKnowledge "the knowledge of what the square root of a number is, including a few examples")
AnnotationAssertion(skos:scopeNote know:PieceOfKnowledge "A Piece of Knowledge must be interpreted as a generically dependent continuant (GDC): an instance is the (abstract) information content that any agent can represent internally, or that any artifact can carry, without depending on any one specific agent or carrier. As such, pieces of knowledge correspond to the class of equivalence of the internal and/or carried representations, across different agents and/or carriers. 
Members of that class - e.g. the knowledge as internally represented by one specific agent  - are specifically dependent continuants (SDC). Specifically dependent continuants may realize the knowledge with some variation in practice, but are not of interest until communicated and diffused again, possibly as a variation/derivation/evolution of the original knowledge. Hence, the API4KP notion of Knowledge focuses on GDC, recognizing the role of individual SDCs.")
SubClassOf(know:PieceOfKnowledge know:Knowledge)
SubClassOf(know:PieceOfKnowledge ObjectSomeValuesFrom(know:part-of know:Knowledge))

# Class: know:PrescriptiveGrammar (prescriptive grammar)

AnnotationAssertion(rdfs:label know:PrescriptiveGrammar "prescriptive grammar")
AnnotationAssertion(rdfs:seeAlso know:PrescriptiveGrammar "https://www.teachingenglish.org.uk/article/descriptive-grammar")
AnnotationAssertion(skos:definition know:PrescriptiveGrammar "a grammar that describes how a language should be used correctly")
SubClassOf(know:PrescriptiveGrammar know:Grammar)

# Class: know:PrimitiveConcept (primitive concept)

AnnotationAssertion(rdfs:comment know:PrimitiveConcept "When expressed in OWL, primitive concepts are not the subject of subClassOf or equivalentClass axioms")
AnnotationAssertion(rdfs:label know:PrimitiveConcept "primitive concept")
AnnotationAssertion(skos:definition know:PrimitiveConcept "A concept that does not need an explicit definition. 

Concepts of this kind are usually acquired through experience, and/or are considered part of Common Knowledge (Knowledge that every agent possesses, and is expected by other agents to possess). 

As such, they live at the boundaries of the semantic graphs that constitute a work of knowledge, and their definition (if any exists) does not need to be communicated")
AnnotationAssertion(skos:scopeNote know:PrimitiveConcept "The notion of 'Common Knowledge' may be universal, or be scoped to a domain. That is, certain concepts can be expected to be represented by any intelligent agent (e.g. the concept of the number \"one\"), while others may depend on the nature of the agent (e.g. feelings are natural to human beings, not so much to computer agents), or on their expertise (e.g. the notion of \"physiology\" requires expertise in medicine).

This class of 'primitive' concept does not make a distinction, and assumes that 'primitive' is based on the context in which the ontology is used.")
EquivalentClasses(know:PrimitiveConcept ObjectIntersectionOf(know:AtomicConcept ObjectComplementOf(ObjectSomeValuesFrom(know:captured-by know:WorkOfKnowledge))))
SubClassOf(know:PrimitiveConcept know:AtomicConcept)

# Class: know:Profile (profile)

AnnotationAssertion(rdfs:label know:Profile "profile")
AnnotationAssertion(skos:altLabel know:Profile "Linguistic Profile")
AnnotationAssertion(skos:definition know:Profile "A profile is a restricted abstract syntax that limits the expressvity of (the admissible expression in) a given language, usually to reduce the complexity, narrow the scope, and/or improve the semantic clarity of the expressions")
EquivalentClasses(know:Profile ObjectIntersectionOf(know:AbstractSyntax ObjectSomeValuesFrom(know:profiles know:AbstractSyntax)))
SubClassOf(know:Profile know:AbstractSyntax)

# Class: know:SelfContainedKnowledgeArtifact (Self-Contained Knowledge Artifact)

AnnotationAssertion(rdfs:comment know:SelfContainedKnowledgeArtifact "As an instance of a self-contained manifestation, it carries all the expression(s) needed to understand its content, if any dependencies exist")
AnnotationAssertion(rdfs:label know:SelfContainedKnowledgeArtifact "Self-Contained Knowledge Artifact"@en)
AnnotationAssertion(skos:definition know:SelfContainedKnowledgeArtifact "A Knowledge Artifact that is an exemplar of a self-contained manifestation")
SubClassOf(know:SelfContainedKnowledgeArtifact know:KnowledgeArtifact)

# Class: know:Serialization (concrete syntax)

AnnotationAssertion(rdfs:label know:Serialization "concrete syntax"@en)
AnnotationAssertion(skos:altLabel know:Serialization "serialization")
AnnotationAssertion(skos:definition know:Serialization "The set of structures and/or rules that constrain the parse tree of a valid sentence of a language, itself expressed in some (meta) language")
SubClassOf(know:Serialization know:Syntax)
SubClassOf(know:Serialization ObjectSomeValuesFrom(know:externalizes know:AbstractSyntax))

# Class: know:Software (software)

AnnotationAssertion(rdfs:label know:Software "software")
AnnotationAssertion(skos:definition know:Software "Concrete Expression, in an executable language, that specifies and/or directs the behaviour of a (virtual) machine")
AnnotationAssertion(skos:note know:Software "A Software is a \"Performance Plan\" for a (virtual) machine to execute")
SubClassOf(know:Software know:ConcreteExpression)
SubClassOf(know:Software ObjectSomeValuesFrom(know:uses-language know:MachineExecutableLanguage))

# Class: know:Specification (specification)

AnnotationAssertion(rdfs:comment know:Specification "TODO: Does OMG have a standard def?")
AnnotationAssertion(rdfs:label know:Specification "specification")
AnnotationAssertion(skos:definition know:Specification "prescriptive expression of knowledge about the expected and/or required behavior of a system")
SubClassOf(know:Specification know:KnowledgeResource)

# Class: know:StructuredKnowledgeResource (Structured Knowledge Resource)

AnnotationAssertion(rdfs:label know:StructuredKnowledgeResource "Structured Knowledge Resource"@en)
AnnotationAssertion(skos:definition know:StructuredKnowledgeResource "Knowledge Resource that is the result of a structuring operation, that takes a number of other Knowledge Resources as Inputs")
SubClassOf(know:StructuredKnowledgeResource know:KnowledgeResource)

# Class: know:StructuringKnowledgeResource (structuring knowledge resource)

AnnotationAssertion(rdfs:label know:StructuringKnowledgeResource "structure")
AnnotationAssertion(rdfs:label know:StructuringKnowledgeResource "structuring knowledge resource")
AnnotationAssertion(skos:definition know:StructuringKnowledgeResource "A knowledge resource that defines - declaratively or procedurally - how other resources can be aggregated or composed into a structured resource")
SubClassOf(know:StructuringKnowledgeResource know:KnowledgeResource)

# Class: know:Syntax (syntax)

AnnotationAssertion(rdfs:comment know:Syntax "Syntaxes are 'reconstructed' from natural languages, but designed in the case of constructed languages")
AnnotationAssertion(rdfs:comment know:Syntax "This notion of Syntax is defined at the Abstract Expression Level. 
For comparison, see 'Notation' and 'Formal Grammar'")
AnnotationAssertion(rdfs:label know:Syntax "syntax"@en)
AnnotationAssertion(skos:definition know:Syntax "The set of structures and/or rules that constrain a valid sentence of a language, itself expressed in some (meta) language")
SubClassOf(know:Syntax know:Specification)
SubClassOf(know:Syntax ObjectSomeValuesFrom(know:expresses know:Grammar))

# Class: know:VersionedIdentifier (versioned identifier)

AnnotationAssertion(rdfs:label know:VersionedIdentifier "versioned identifier")
AnnotationAssertion(skos:definition know:VersionedIdentifier "Identifier of a particular version of a given entity, i.e. the particular configuration of (mutable) qualities of a given entity over a specific period of time")
SubClassOf(know:VersionedIdentifier know:Identifier)

# Class: know:VersionedKnowledgeEndeavor (versioned knowledge endeavor)

AnnotationAssertion(rdfs:comment know:VersionedKnowledgeEndeavor "versioned endeavors are identified explicitly by a version identifier")
AnnotationAssertion(rdfs:label know:VersionedKnowledgeEndeavor "versioned knowledge endeavor")
AnnotationAssertion(skos:definition know:VersionedKnowledgeEndeavor "endeavor that is part of a series - a temporally ordered chain of endeavors of the same type, related by the fact that each successor is a revision of its predecessor.")
SubClassOf(know:VersionedKnowledgeEndeavor know:KnowledgeEndeavour)
SubClassOf(know:VersionedKnowledgeEndeavor ObjectSomeValuesFrom(know:identified-by know:VersionedIdentifier))

# Class: know:WorkOfKnowledge (work of knowledge)

AnnotationAssertion(rdfs:comment know:WorkOfKnowledge "A Work of Knowledge can be conceptualized in terms of an Abstract  Semantic Graph")
AnnotationAssertion(rdfs:comment know:WorkOfKnowledge "The Activity that generates the Intellectual Work consists in identifying, selecting and preparing the Concepts that are intended to be expressed and communicated.")
AnnotationAssertion(rdfs:comment know:WorkOfKnowledge "The term 'Work of Knowledge' mirrors the term 'Work of Art'")
AnnotationAssertion(rdfs:label know:WorkOfKnowledge "work of knowledge")
AnnotationAssertion(rdfs:seeAlso know:WorkOfKnowledge "http://www.tlainc.com/articl134.htm")
AnnotationAssertion(rdfs:seeAlso know:WorkOfKnowledge "https://en.wikipedia.org/wiki/Abstract_semantic_graph")
AnnotationAssertion(skos:definition know:WorkOfKnowledge "An Explicit (i.e. non Tacit) Piece of Knowledge that is the result of one or more (possibly non-deterministic) graph productions applied to some (chosen Piece of) Knowledge, intended for representation and/or communication.")
AnnotationAssertion(skos:definition know:WorkOfKnowledge "An Intellectual Work that captures some (piece of) Knowledge, which itself has a subject that can be reflected in the Work by means of one or more explicitly marked, 'focal' concepts")
AnnotationAssertion(skos:example know:WorkOfKnowledge "a formal Ontology, prepared by an ontologist, and engineered to answer a number of competency questions, independently of the actual formal language used to express it.")
AnnotationAssertion(skos:example know:WorkOfKnowledge "a lecture, as the outcome of a teacher's choosing and organizing the topics so they can be explained to the students.")
AnnotationAssertion(skos:example know:WorkOfKnowledge "a statistician's description of a stochastic process by means of a Markov model")
AnnotationAssertion(skos:example know:WorkOfKnowledge "an algorithm for the extraction of the square root of a number")
AnnotationAssertion(skos:example know:WorkOfKnowledge "the content of a newspaper article, as determined by a journalist deciding what facts and/or opinions to include, and how to present them, independently of any editorial and/or formatting")
SubClassOf(know:WorkOfKnowledge know:IntellectualWork)
SubClassOf(know:WorkOfKnowledge know:PieceOfKnowledge)
SubClassOf(know:WorkOfKnowledge ObjectSomeValuesFrom(know:captures know:PieceOfKnowledge))
SubClassOf(know:WorkOfKnowledge ObjectSomeValuesFrom(know:has-part know:AtomicConcept))
SubClassOf(know:WorkOfKnowledge ObjectSomeValuesFrom(know:product-of know:KnowledgeActivity))


SubClassOf(ObjectSomeValuesFrom(know:performs know:KnowledgeActivity) know:KnowledgeableAgent)
DisjointClasses(know:IntellectualWork know:KnowledgeArtifact know:KnowledgeExpression)
SubObjectPropertyOf(ObjectPropertyChain(know:conceptualizes know:serialized-into) know:concretely-expressed-by)
SubObjectPropertyOf(ObjectPropertyChain(know:defined-by know:uses-concept) know:associated-to)
SubObjectPropertyOf(ObjectPropertyChain(know:engraved-with know:encoding-of) know:carries)
SubObjectPropertyOf(ObjectPropertyChain(know:expresses know:captures) know:knowledge-representation-of)
SubObjectPropertyOf(ObjectPropertyChain(know:expresses know:has-subject) know:representation-of)
SubObjectPropertyOf(ObjectPropertyChain(know:has-encoding know:engraved-on) know:carried-by)
SubObjectPropertyOf(ObjectPropertyChain(know:serialization-of know:expresses) know:concretely-expresses)
SubObjectPropertyOf(ObjectPropertyChain(know:serialized-into know:uses-concrete-syntax) know:is-serialized-in)
SubObjectPropertyOf(ObjectPropertyChain(know:supports-expression know:profiles) know:supports-expression)
SubObjectPropertyOf(ObjectPropertyChain(know:supports-serialization know:externalizes) know:supports-expression)
SubObjectPropertyOf(ObjectPropertyChain(know:supports-serialization know:limits) know:supports-serialization)
SubObjectPropertyOf(ObjectPropertyChain(know:uses-language know:has-wordstock) know:uses-lexicon)
)